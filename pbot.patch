Index: src/game/g_local.h
===================================================================
--- src/game/g_local.h	(revision 2220)
+++ src/game/g_local.h	(working copy)
@@ -43,6 +43,9 @@
 #define INTERMISSION_DELAY_TIME 1000
 #define SP_INTERMISSION_DELAY_TIME 5000
 
+#define MAX_PATHS	200 //try not to make it over 1000 or there will be problems.
+#define MAX_PATH_NODES	5 //do not change
+
 // gentity->flags
 #define FL_GODMODE        0x00000010
 #define FL_NOTARGET       0x00000020
@@ -53,6 +56,11 @@
 #define FL_NO_HUMANS      0x00004000  // spawn point just for bots
 #define FL_FORCE_GESTURE  0x00008000  // spawn point just for bots
 
+#define BOT_JUMP		1
+#define BOT_WALLCLIMB		2
+#define BOT_KNEEL		3
+#define BOT_POUNCE		4
+
 // movers are things like doors, plats, buttons, etc
 typedef enum
 {
@@ -74,6 +82,40 @@
 
 #define SP_PODIUM_MODEL   "models/mapobjects/podium/podium4.md3"
 
+//ROTAX
+typedef enum
+{
+  BOT_REGULAR = 1,
+  BOT_IDLE,
+  BOT_ATTACK,
+  BOT_STAND_GROUND,
+  BOT_DEFENSIVE,
+  BOT_FOLLOW_FRIEND_PROTECT,
+  BOT_FOLLOW_FRIEND_ATTACK,
+  BOT_FOLLOW_FRIEND_IDLE,
+  BOT_TEAM_KILLER
+} botCommand_t;
+
+typedef struct
+{
+	vec3_t	coord;
+	int	nextid[5];
+	int	random;
+	int	timeout;
+	int	action;
+} path;
+
+
+
+typedef enum
+{
+	TARGETPATH,
+	FINDNEXTPATH,
+	FINDNEWPATH,
+	LOST
+} botstate;
+
+
 //============================================================================
 
 struct gentity_s
@@ -186,9 +228,41 @@
 
   int               noise_index;
 
+  //ROTAX
+  //for targeting following
+  botCommand_t		botCommand;
+  gentity_t		*botEnemy;
+  gentity_t		*botFriend;
+  int			enemytime;
+  int			botFriendLastSeen;  
+  int			botEnemyLastSeen;
+  int			botSkillLevel;
+  team_t		botTeam;
+  qboolean		nextNode;
+  qboolean		pathChosen;
+  int			targetPath;
+  int			targetNode;
+  int			timeFoundPath;
+  botstate		state;
+  int			buytime;
+  int			evolvetime;
+  qboolean		isblocked;
+  //vec3_t		OldPos[20];
+  int			pathid;
+  int			movepathid;
+  int			discpathid;
+  int			lastpathid;
+  qboolean		patheditor;
+  
+  
+  
   // timing variables
   float             wait;
   float             random;
+  int			jumptime;
+  int			searchtime;
+  int			checktime;
+ 
 
   team_t            stageTeam;
   stage_t           stageStage;
@@ -412,7 +486,8 @@
   int                 time100;          // timer for 100ms interval events
   int                 time1000;         // timer for one second interval events
   int                 time10000;        // timer for ten second interval events
-
+  int		      bottime;
+  
   char                *areabits;
 
   int                 lastPoisonTime;
@@ -669,6 +744,9 @@
   int               numTeamImbalanceWarnings;
 
   voice_t           *voices;
+  path		paths[MAX_PATHS];
+  int		numPaths;
+  qboolean	drawpath;
 
   emoticon_t        emoticons[ MAX_EMOTICONS ];
   int               emoticonCount;
@@ -708,7 +786,26 @@
 void      G_SpawnEntitiesFromString( void );
 char      *G_NewString( const char *string );
 
+//ROTAX
+// g_bot.c
 //
+void G_BotAdd( char *name, team_t team, int skill, int ignore );
+void G_BotDel( int clientNum );
+void G_DeleteBots( void );
+void G_BotReload( gentity_t *ent, int clientNum );
+void G_BotCmd( gentity_t *master, int clientNum, char *command, int skill );
+void G_BotThink( gentity_t *self );
+void G_FrameAim( gentity_t *self );
+void G_FastThink( gentity_t *self );
+void G_BotSpectatorThink( gentity_t *self );
+// todo: are these suppose to be out here?! Why not?
+qboolean botAimAtTarget( gentity_t *self, gentity_t *target );
+int botFindClosestEnemy( gentity_t *self, qboolean includeTeam );
+qboolean botTargetInRange( gentity_t *self, gentity_t *target );
+int botGetDistanceBetweenPlayer( gentity_t *self, gentity_t *player );
+qboolean botShootIfTargetInRange( gentity_t *self, gentity_t *target );
+
+//
 // g_cmds.c
 //
 
@@ -1176,6 +1273,33 @@
 
 extern  vmCvar_t  g_censorship;
 
+// ROTAX
+extern  vmCvar_t  g_pathediting;
+extern  vmCvar_t  g_pathpassword;
+extern  vmCvar_t  g_human_range;
+extern  vmCvar_t  g_human_strafe;
+extern  vmCvar_t  g_level0_range;
+extern  vmCvar_t  g_level1_range;
+extern  vmCvar_t  g_level1UPG_range;
+extern  vmCvar_t  g_level2_range;
+extern  vmCvar_t  g_level2UPG_range;
+extern  vmCvar_t  g_level3_range;
+extern  vmCvar_t  g_level3UPG_range;
+extern  vmCvar_t  g_level4_range;
+extern  vmCvar_t  g_bot;
+extern  vmCvar_t  g_bot_spawnprotection;
+extern  vmCvar_t  g_bot_evolve;
+extern  vmCvar_t  g_bot_mgun;
+extern  vmCvar_t  g_bot_shotgun;
+extern  vmCvar_t  g_bot_psaw;
+extern  vmCvar_t  g_bot_lasgun;
+extern  vmCvar_t  g_bot_mdriver;
+extern  vmCvar_t  g_bot_chaingun;
+extern  vmCvar_t  g_bot_prifle;
+extern  vmCvar_t  g_bot_flamer;
+extern  vmCvar_t  g_bot_lcannon;
+
+
 void      trap_Print( const char *fmt );
 void      trap_Error( const char *fmt );
 int       trap_Milliseconds( void );
@@ -1227,3 +1351,6 @@
 
 void      trap_AddCommand( const char *cmdName );
 void      trap_RemoveCommand( const char *cmdName );
+
+gentity_t *spawnnode( gentity_t *self, long id );
+void nodethink(gentity_t *ent);
Index: src/game/g_active.c
===================================================================
--- src/game/g_active.c	(revision 2220)
+++ src/game/g_active.c	(working copy)
@@ -398,7 +398,7 @@
             !( client->oldbuttons & BUTTON_ATTACK );
   attack3 = ( client->buttons & BUTTON_USE_HOLDABLE ) &&
             !( client->oldbuttons & BUTTON_USE_HOLDABLE );
-   
+  
   // We are in following mode only if we are following a non-spectating client           
   following = client->sess.spectatorState == SPECTATOR_FOLLOW;
   if( following )
@@ -410,6 +410,13 @@
       following = qfalse;
   }
   
+  //ROTAX
+	//if bot
+  if( ent->r.svFlags & SVF_BOT && g_bot.integer ) {
+    	G_BotSpectatorThink( ent );
+    	//return;
+  }
+  
   // Check to see if we are in the spawn queue
   if( client->pers.teamSelection == TEAM_ALIENS )
     queued = G_SearchSpawnQueue( &level.alienSpawnQueue, ent - g_entities );
@@ -590,10 +597,27 @@
   client->time100 += msec;
   client->time1000 += msec;
   client->time10000 += msec;
+  client->bottime += msec;
 
   while ( client->time100 >= 100 )
   {
     weapon_t weapon = BG_GetPlayerWeapon( &client->ps );
+    
+    //ROTAX
+	if( ent->r.svFlags & SVF_BOT )
+	{
+	  if( g_bot.integer )
+		{
+			G_FastThink( ent );
+		}
+		else
+		{
+			ent->client->pers.cmd.buttons = 0;
+			ent->client->pers.cmd.forwardmove = 0;
+			ent->client->pers.cmd.upmove = 0;
+			ent->client->pers.cmd.rightmove = 0;
+		}
+	}
   
     client->time100 -= 100;
 
@@ -700,6 +724,26 @@
     }
   }
 
+  while ( client->bottime >= 300 )
+  {
+	//ROTAX
+	if( ent->r.svFlags & SVF_BOT )
+	{
+		if(g_bot.integer)
+		{
+		  G_BotThink( ent );
+		}
+		else
+		{
+			ent->client->pers.cmd.buttons = 0;
+			ent->client->pers.cmd.forwardmove = 0;
+			ent->client->pers.cmd.upmove = 0;
+			ent->client->pers.cmd.rightmove = 0;
+		}
+	}
+	client->bottime -= 300;
+  }
+  
   while( client->time1000 >= 1000 )
   {
     client->time1000 -= 1000;
@@ -1310,6 +1354,22 @@
   // check for inactivity timer, but never drop the local client of a non-dedicated server
   if( !ClientInactivityTimer( ent ) )
     return;
+  
+  if( ent->r.svFlags & SVF_BOT )
+	{
+		if(g_bot.integer > 0)
+		{
+			G_FrameAim( ent );
+		}
+		else
+		{
+			ent->client->pers.cmd.buttons = 0;
+			ent->client->pers.cmd.forwardmove = 0;
+			ent->client->pers.cmd.upmove = 0;
+			ent->client->pers.cmd.rightmove = 0;
+		}
+	}
+	
 
   // calculate where ent is currently seeing all the other active clients
   G_UnlaggedCalc( ent->client->unlaggedTime, ent );
@@ -1760,14 +1820,15 @@
   // phone jack if they don't get any for a while
   ent->client->lastCmdTime = level.time;
 
-  if( !g_synchronousClients.integer )
+//ROTAX
+  if( !( ent->r.svFlags & SVF_BOT ) && !g_synchronousClients.integer )
     ClientThink_real( ent );
 }
 
 
 void G_RunClient( gentity_t *ent )
 {
-  if( !g_synchronousClients.integer )
+  if( !( ent->r.svFlags & SVF_BOT ) && !g_synchronousClients.integer )
     return;
 
   ent->client->pers.cmd.serverTime = level.time;
Index: src/game/g_public.h
===================================================================
--- src/game/g_public.h	(revision 2220)
+++ src/game/g_public.h	(working copy)
@@ -33,6 +33,10 @@
 
 #define SVF_CLIENTMASK 0x00000002
 
+//ROTAX
+#define SVF_BOT			0x00000008	// set if the entity is a bot
+
+
 #define SVF_BROADCAST           0x00000020  // send to all connected clients
 #define SVF_PORTAL              0x00000040  // merge a second pvs at origin2 into snapshots
 #define SVF_USE_CURRENT_ORIGIN  0x00000080  // entity->r.currentOrigin instead of entity->s.origin
Index: src/game/g_main.c
===================================================================
--- src/game/g_main.c	(revision 2220)
+++ src/game/g_main.c	(working copy)
@@ -143,7 +143,34 @@
 
 vmCvar_t  g_tag;
 
+// ROTAX
+vmCvar_t  g_pathediting;
+vmCvar_t  g_pathpassword;
+vmCvar_t  g_human_range;
+vmCvar_t  g_human_strafe;
+vmCvar_t  g_level0_range;
+vmCvar_t  g_level1_range;
+vmCvar_t  g_level1UPG_range;
+vmCvar_t  g_level2_range;
+vmCvar_t  g_level2UPG_range;
+vmCvar_t  g_level3_range;
+vmCvar_t  g_level3UPG_range;
+vmCvar_t  g_level4_range;
+vmCvar_t  g_bot;
+vmCvar_t  g_bot_spawnprotection;
+vmCvar_t  g_bot_evolve;
+vmCvar_t  g_bot_mgun;
+vmCvar_t  g_bot_shotgun;
+vmCvar_t  g_bot_psaw;
+vmCvar_t  g_bot_lasgun;
+vmCvar_t  g_bot_mdriver;
+vmCvar_t  g_bot_chaingun;
+vmCvar_t  g_bot_prifle;
+vmCvar_t  g_bot_flamer;
+vmCvar_t  g_bot_lcannon;
 
+
+
 // copy cvars that can be set in worldspawn so they can be restored later
 static char cv_gravity[ MAX_CVAR_VALUE_STRING ];
 static char cv_humanMaxStage[ MAX_CVAR_VALUE_STRING ];
@@ -186,7 +213,31 @@
   { &g_logFileSync, "g_logFileSync", "0", CVAR_ARCHIVE, 0, qfalse  },
 
   { &g_password, "g_password", "", CVAR_USERINFO, 0, qfalse  },
-
+  { &g_pathediting, "g_pathediting", "0", CVAR_ARCHIVE, 0, qfalse },
+  { &g_bot, "g_bot", "1", CVAR_ARCHIVE, 0, qfalse },
+  { &g_bot_spawnprotection, "g_bot_spawnprotection", "2000", CVAR_ARCHIVE, 0, qfalse },
+  { &g_human_range, "g_human_range", "3000", CVAR_ARCHIVE, 0, qfalse },
+  { &g_human_strafe, "g_human_strafe", "0", CVAR_ARCHIVE, 0, qfalse },
+  { &g_level0_range, "g_level0_range", "300", CVAR_ARCHIVE, 0, qfalse },
+  { &g_level1_range, "g_level1_range", "300", CVAR_ARCHIVE, 0, qfalse },
+  { &g_level1UPG_range, "g_level1UPG_range", "300", CVAR_ARCHIVE, 0, qfalse },
+  { &g_level2_range, "g_level2_range", "350", CVAR_ARCHIVE, 0, qfalse },
+  { &g_level2UPG_range, "g_level2UPG_range", "400", CVAR_ARCHIVE, 0, qfalse },
+  { &g_level3_range, "g_level3_range", "500", CVAR_ARCHIVE, 0, qfalse },
+  { &g_level3UPG_range, "g_level3UPG_range", "600", CVAR_ARCHIVE, 0, qfalse },
+  { &g_level4_range, "g_level4_range", "300", CVAR_ARCHIVE, 0, qfalse },
+  { &g_bot_evolve, "g_bot_evolve", "1", CVAR_ARCHIVE, 0, qfalse },
+  { &g_bot_mgun, "g_bot_mgun", "1", CVAR_ARCHIVE, 0, qfalse },
+  { &g_bot_shotgun, "g_bot_shotgun", "1", CVAR_ARCHIVE, 0, qfalse },
+  { &g_bot_psaw, "g_bot_psaw", "1", CVAR_ARCHIVE, 0, qfalse },
+  { &g_bot_lasgun, "g_bot_lasgun", "1", CVAR_ARCHIVE, 0, qfalse },
+  { &g_bot_mdriver, "g_bot_mdriver", "1", CVAR_ARCHIVE, 0, qfalse },
+  { &g_bot_chaingun, "g_bot_chaingun", "1", CVAR_ARCHIVE, 0, qfalse },
+  { &g_bot_prifle, "g_bot_prifle", "1", CVAR_ARCHIVE, 0, qfalse },
+  { &g_bot_flamer, "g_bot_flamer", "1", CVAR_ARCHIVE, 0, qfalse },
+  { &g_bot_lcannon, "g_bot_lcannon", "1", CVAR_ARCHIVE, 0, qfalse },
+  { &g_pathpassword, "g_pathpassword", "", CVAR_ARCHIVE, 0, qfalse },
+  
   { &g_needpass, "g_needpass", "0", CVAR_SERVERINFO | CVAR_ROM, 0, qfalse },
 
   { &g_dedicated, "dedicated", "0", 0, 0, qfalse  },
@@ -530,6 +581,83 @@
 
 /*
 ============
+G_PathLoad
+
+============
+*/
+
+void G_PathLoad( void )
+{
+	int i = 0;
+	fileHandle_t f;
+	int len;
+	char *path;
+	char line[ MAX_STRING_CHARS ];
+	char map[ MAX_QPATH ];
+	level.numPaths = 0;
+	trap_Cvar_VariableStringBuffer( "mapname", map, sizeof( map ) );
+	for(i = 0; i < MAX_PATHS;i++)
+	{
+		level.paths[i].coord[0] = 0;
+		level.paths[i].coord[1] = 0;
+		level.paths[i].coord[2] = 0;
+		level.paths[i].nextid[0] = -1;
+		level.paths[i].nextid[1] = -1;
+		level.paths[i].nextid[2] = -1;
+		level.paths[i].nextid[3] = -1;
+		level.paths[i].nextid[4] = -1;
+		level.paths[i].random = -1;
+		level.paths[i].timeout = 10000;
+		level.paths[i].action = 0;
+	}
+	len = trap_FS_FOpenFile( va( "paths/%s/path.dat", map ), &f, FS_READ );
+	if( len < 0 )
+	{
+ 		G_Printf( "Found no path.dat for map\n" );
+		return;
+	}
+	path = BG_Alloc( len + 1 );
+	trap_FS_Read( path, len, f );
+	*( path + len ) = '\0';
+	trap_FS_FCloseFile( f );
+	i = 0;
+	while( *path )
+	{
+		if( i >= sizeof( line ) - 1 )
+		{
+			G_Printf( "Error loading path.dat for map\n" );
+			return;
+		}
+		line[ i++ ] = *path;
+		line[ i ] = '\0';
+		if( *path == '\n' )
+		{
+			i = 0; 
+			if( level.numPaths >= MAX_PATHS ){G_Printf( "Reached path limit\n" );return;}
+			sscanf( line, "%d %f %f %f %d %d %d %d %d %d %d %d\n", 
+						&level.numPaths,
+						&level.paths[level.numPaths].coord[0], 
+						&level.paths[level.numPaths].coord[1], 
+						&level.paths[level.numPaths].coord[2],
+						&level.paths[level.numPaths].nextid[0],
+						&level.paths[level.numPaths].nextid[1],
+						&level.paths[level.numPaths].nextid[2],
+						&level.paths[level.numPaths].nextid[3],
+						&level.paths[level.numPaths].nextid[4],
+						&level.paths[level.numPaths].random,
+						&level.paths[level.numPaths].timeout,
+						&level.paths[level.numPaths].action ); 
+			if(level.paths[level.numPaths].timeout <= 0){level.paths[level.numPaths].timeout = 10000;}
+			level.numPaths ++;
+		}
+	path++;
+	}
+	G_Printf( va("Loaded %d paths\n", level.numPaths) );
+}
+
+
+/*
+============
 G_InitGame
 
 ============
@@ -644,6 +772,9 @@
   // general initialization
   G_FindTeams( );
 
+  // Load path file
+  G_PathLoad( );
+  
   BG_InitClassConfigs( );
   BG_InitBuildableConfigs( );
   G_InitDamageLocations( );
@@ -706,7 +837,7 @@
 {
   // in case of a map_restart
   G_ClearVotes( );
-
+  G_DeleteBots( );
   G_RestoreCvars( );
 
   G_Printf( "==== ShutdownGame ====\n" );
Index: src/game/g_admin.c
===================================================================
--- src/game/g_admin.c	(revision 2220)
+++ src/game/g_admin.c	(working copy)
@@ -74,6 +74,17 @@
       "specified",
       "[^3name|slot#|IP(/mask)^7] (^5duration^7) (^5reason^7)"
     },
+    
+    //ROTAX
+    {"bot", G_admin_bot, qfalse, "bot",
+      "Add or delete bot(s)",
+      "[^3add/del^7] [name] [^5aliens/humans^7] (skill)"
+    },
+    
+    {"botcmd", G_admin_botcmd, qfalse, "botcmd",
+      "Change bot behavior.",
+      "[^3name^7] [^5regular/idle/attack/standground/defensive/followprotect/followattack/followidle/teamkill^7]"
+    },
 
     {"builder", G_admin_builder, qtrue, "builder",
       "show who built a structure",
@@ -99,6 +110,11 @@
       "take away a player's ability to build",
       "[^3name|slot#^7]"
     },
+    
+    {"dnodes", G_drawnodes, qfalse, "drawnodes",
+      "show or hide nodes",
+      ""
+    },
 
     {"kick", G_admin_kick, qfalse, "kick",
       "kick a player with an optional reason",
@@ -139,6 +155,11 @@
       "go to the next map in the cycle",
       ""
     },
+    
+    {"passcode", G_password, qfalse, "passcode",
+      "Password used for various functions",
+      "(^5password^7)"
+    },
 
     {"passvote", G_admin_endvote, qfalse, "passvote",
       "pass a vote currently taking place",
@@ -3277,3 +3298,257 @@
   g_admin_commands = NULL;
   BG_DefragmentMemory( );
 }
+
+//ROTAX
+qboolean G_admin_bot( gentity_t *ent ) {
+        // add [name] (team) (skill)
+        // del [name]
+        int minargc;
+
+        char command[10];
+        char name[ MAX_NAME_LENGTH ];
+        char name_s[ MAX_NAME_LENGTH ];
+        //char name2[ MAX_NAME_LENGTH ];
+        char name2_s[ MAX_NAME_LENGTH ];
+        char team[10];
+        team_t team_int;
+        char skill[2];
+        int skill_int;
+        qboolean success = qfalse;
+        int i, j;
+        namelog_t *namelog;
+
+        //char s2[ MAX_NAME_LENGTH ];
+        //char n2[ MAX_NAME_LENGTH ];
+        //int logmatch = -1, logmatches = 0;
+        //int i, j;
+        //qboolean exactmatch = qfalse;
+
+        minargc = 3;
+        if( trap_Argc() < minargc )     {
+                ADMP( "^7Please have at least command and name.\n" );
+                ADMP( "^3!bot: ^7usage: !bot [add/del] [name] (team) (skill)\n" );
+                return qfalse;
+        }
+
+        trap_Argv( 1, command, sizeof( command ) );
+        trap_Argv( 2, name, sizeof( name ) );
+        G_SanitiseString( name, name_s, sizeof(name_s) );
+
+        if(!Q_stricmp(command,"add")) {
+                // add [name] [team] (skill)
+                minargc = 4;
+                if( trap_Argc() < minargc )     {
+                        ADMP( "^7Please have at least name and team.\n" );
+                        ADMP( "^3!bot: ^7usage: !bot [add/del] [name] [humans/aliens] (skill)\n" );
+                        return qfalse;
+                }
+
+                trap_Argv( 3, team, sizeof( team ) );
+
+                if(!Q_stricmp(team,"humans")) {
+                        team_int = TEAM_HUMANS;
+                } else if(!Q_stricmp(team,"aliens")) {
+                        team_int = TEAM_ALIENS;
+                } else {
+                        ADMP( "^7Invalid bot team.\n" );
+                        ADMP( "^3!bot: ^7usage: !bot add [name] [humans/aliens] (skill)\n" );
+                        return qfalse;
+                }
+
+                minargc = 5;
+                if(trap_Argc() < minargc) {
+                        skill_int = 0;
+                } else {
+                        trap_Argv( 4, skill, sizeof( skill ) );
+                        skill_int = atoi(skill);
+                }
+
+                // got name, team_int and skill_int
+                G_BotAdd(name, team_int, skill_int, -1);
+                return qtrue;
+        } else if(!Q_stricmp(command,"del")) {
+                // del [name]
+                success = qfalse;
+//               for( i = 0; i < MAX_NAMELOG_NAMES && namelog[ i ];i++ ) {
+                 for( namelog = level.namelogs; namelog; namelog = namelog->next )
+                        if( namelog->slot >= 0 ) {
+                                for( j = 0; j < MAX_NAMELOG_NAMES && namelog->name[ j ][ 0 ]; j++ ) {
+                                        G_SanitiseString(namelog->name[ j ], name2_s, sizeof(name2_s) );
+                                        if( strstr( name2_s, name_s ) ) {
+                                                G_BotDel(namelog->slot);
+                                                success = qtrue;
+                                        }
+                                }
+                        }
+                }
+
+                return success;
+                //ADMP( "delete not implemented yet\n" );
+                //return qfalse;
+}
+
+qboolean G_admin_botcmd( gentity_t *ent ) {
+        int minargc;
+        char name[ MAX_NAME_LENGTH ];
+        char name_s[ MAX_NAME_LENGTH ];
+        char name2_s[ MAX_NAME_LENGTH ];
+        char skill[100];
+        char command[ 32 ];
+        int i, j;
+        qboolean success = qfalse;
+        namelog_t *namelog;
+
+        //[botname] [command]
+        minargc = 3;
+        if( trap_Argc() < minargc )     {
+                ADMP( "^3!botcmd: ^7usage: !botcmd [botname] [command]\n" );
+                return qfalse;
+        }
+
+        trap_Argv( 1, name, sizeof( name ) );
+        trap_Argv( 2, command, sizeof( command ) );
+        trap_Argv( 3, skill, sizeof( skill ) );
+        trap_SendServerCommand(ent - g_entities, va("print \"%s %s %s\n\"", name, command, skill ) );
+        G_SanitiseString( name, name_s, sizeof(name_s) );
+
+        success = qfalse;
+        //for( i = 0; i < MAX_NAMELOG_NAMES && namelog[ i ];i++ ) {
+          for( namelog = level.namelogs; namelog; namelog = namelog->next )
+                if( namelog->slot >= 0 ) {
+                        for( j = 0; j < MAX_NAMELOG_NAMES && namelog->name[ j ][ 0 ]; j++ ) {
+                                G_SanitiseString(namelog->name[ j ], name2_s, sizeof(name2_s) );
+                                if( strstr( name2_s, name_s ) ) {
+                                        G_BotCmd(ent, namelog->slot,command, atoi(skill) );
+                                        success = qtrue;
+                                }
+                        }
+                }
+        
+
+        return success;
+
+}
+
+qboolean G_password( gentity_t *ent )
+{
+  char password[ MAX_STRING_CHARS ];
+  if( !g_pathpassword.string[0] ){ADMP( "^3password: Not set (g_pathpassword)\n" );return qfalse;}
+  if( trap_Argc() < 2 )
+  {
+    ADMP( "^3password: ^7usage: password [password]\n" );
+    return qfalse;
+  }
+  trap_Argv( 1, password, sizeof( password ) );
+  if( !strcmp(password, g_pathpassword.string) )
+	ent->patheditor = qtrue;
+  return qtrue;
+}
+
+qboolean G_drawnodes( gentity_t *ent )
+{
+	long i,i2;
+	qboolean draw;
+	if(level.drawpath == qfalse)
+	{
+		ADMP( "^2Drawing Paths\n" );
+		for(i = 0;i < level.numPaths;i++)
+		{
+			draw = qtrue;
+			for(i2 = 0;i2 < 5;i2++)
+			{
+				if(level.paths[i].nextid[i2] < 0)
+				{
+					draw = qfalse;
+				}
+			}
+			if(draw == qtrue)
+			{
+				gentity_t *node;
+				node = spawnnode(ent,i);
+			}
+		}
+		level.drawpath = qtrue;
+		return qtrue;
+	}
+	else
+	{
+		for( i = 0; i < MAX_GENTITIES; i++ )
+		{
+			if(g_entities[i].client){continue;}
+			if(!strcmp("PathNode",g_entities[i].classname))
+			{
+				G_FreeEntity(&g_entities[i]);
+			}
+		}
+		ADMP( "^1Hiding Paths\n" );
+		level.drawpath = qfalse;
+		return qtrue;
+	}
+	//return qfalse; unreachable
+}
+
+void nodethink(gentity_t *ent)
+{
+	int i;
+	vec3_t pos;
+	if(ent->pathid < 0 || level.numPaths <= ent->pathid)
+	{
+		G_FreeEntity(ent);
+		return;
+	}
+	for(i = 0;i < 5;i++)
+	{
+		if(level.paths[ent->pathid].nextid[i] < 0)
+		{
+			G_FreeEntity(ent);
+			return;
+		}
+	}
+	pos[0] = level.paths[ent->pathid].coord[0];
+	pos[1] = level.paths[ent->pathid].coord[1];
+	pos[2] = level.paths[ent->pathid].coord[2];
+	VectorCopy(pos,ent->s.pos.trBase);
+	VectorCopy(pos,ent->r.currentOrigin );
+}
+
+gentity_t *spawnnode( gentity_t *self, long id )
+{
+  vec3_t temp;
+  vec3_t start;
+  gentity_t *bolt;
+  start[0] = level.paths[id].coord[0];
+  start[1] = level.paths[id].coord[1];
+  start[2] = level.paths[id].coord[2];
+  temp[0] = 0;temp[1] = 0;temp[2] = 0;
+  //VectorNormalize (temp);
+
+  bolt = G_Spawn();
+  bolt->classname = "PathNode";
+  bolt->nextthink = level.time + 2000;
+  bolt->think = nodethink;
+  bolt->s.eType = ET_MISSILE;
+  bolt->r.svFlags = SVF_USE_CURRENT_ORIGIN;
+  bolt->s.weapon = WP_PULSE_RIFLE;
+  bolt->s.generic1 = WPM_PRIMARY; //weaponMode
+  bolt->r.ownerNum = self->r.ownerNum;
+  bolt->parent = self;
+  bolt->damage = 0;
+  bolt->splashDamage = 0;
+  bolt->splashRadius = 0;
+  bolt->methodOfDeath = MOD_GRENADE;
+  bolt->splashMethodOfDeath = MOD_GRENADE;
+  bolt->clipmask = 0;//MASK_SHOT; 
+  bolt->target_ent = NULL;
+  bolt->pathid = id;
+  bolt->s.pos.trType = TR_LINEAR;
+  bolt->s.pos.trTime = level.time - 50;   // move a bit on the very first frame
+  VectorCopy( start, bolt->s.pos.trBase );
+  VectorScale( temp, 0, bolt->s.pos.trDelta );
+  SnapVector( bolt->s.pos.trDelta );      // save net bandwidth
+
+  VectorCopy( start, bolt->r.currentOrigin );
+
+  return bolt;
+}
+
Index: src/game/g_admin.h
===================================================================
--- src/game/g_admin.h	(revision 2220)
+++ src/game/g_admin.h	(working copy)
@@ -182,6 +182,11 @@
 qboolean G_admin_builder( gentity_t *ent );
 qboolean G_admin_buildlog( gentity_t *ent );
 qboolean G_admin_revert( gentity_t *ent );
+//ROTAX
+qboolean G_admin_bot( gentity_t *ent );
+qboolean G_admin_botcmd( gentity_t *ent );
+qboolean G_drawnodes( gentity_t *ent );
+qboolean G_password( gentity_t *ent );
 
 void G_admin_print( gentity_t *ent, char *m );
 void G_admin_buffer_print( gentity_t *ent, char *m );
Index: src/game/g_client.c
===================================================================
--- src/game/g_client.c	(revision 2220)
+++ src/game/g_client.c	(working copy)
@@ -1080,15 +1080,15 @@
   for( i = 0; i < sizeof( client->pers.guid ) - 1 &&
               isxdigit( client->pers.guid[ i ] ); i++ );
 
-  if( i < sizeof( client->pers.guid ) - 1 )
+  if( i < sizeof( client->pers.guid ) - 1 && !( ent->r.svFlags & SVF_BOT ) )
     return "Invalid GUID";
-
+  
   for( i = 0; i < level.maxclients; i++ )
   {
     if( level.clients[ i ].pers.connected == CON_DISCONNECTED )
       continue;
 
-    if( !Q_stricmp( client->pers.guid, level.clients[ i ].pers.guid ) )
+    if( !Q_stricmp( client->pers.guid, level.clients[ i ].pers.guid ) && !( ent->r.svFlags & SVF_BOT ) )
     {
       if( !G_ClientIsLagging( level.clients + i ) )
       {
@@ -1110,7 +1110,7 @@
   // get and distribute relevent paramters
   G_namelog_connect( client );
   userInfoError = ClientUserinfoChanged( clientNum, qfalse );
-  if( userInfoError != NULL )
+  if( userInfoError != NULL && !( ent->r.svFlags & SVF_BOT ) )
     return userInfoError;
 
   G_LogPrintf( "ClientConnect: %i [%s] (%s) \"%s^7\" \"%c%s%c^7\"\n",
Index: src/game/g_cmds.c
===================================================================
--- src/game/g_cmds.c	(revision 2220)
+++ src/game/g_cmds.c	(working copy)
@@ -3103,6 +3103,550 @@
   return ms;
 }
 
+/*
+ =================
+ Cmd_Node_f
+ 
+ Spawn/Edit path nodes
+ =================
+ */
+void Cmd_Node_f( gentity_t *ent )
+{
+	char cmd[ MAX_TOKEN_CHARS ] = "";
+	char timeout[ MAX_TOKEN_CHARS ] = "";
+	char action[ MAX_TOKEN_CHARS ] = "";
+	int countz = 0;
+	int countz2 = 0;
+	fileHandle_t f;
+	int len;
+	char *s;
+	char map[ MAX_QPATH ];
+	char fileName[ MAX_OSPATH ];
+	int i,i2,distance,Ax,Ay,Az,Bx,By,Bz = 0;
+	int timeout2 = 0;
+	int nearbynodeid[ MAX_PATHS ];
+	int numnearby = 0;
+	qboolean delpath = qfalse;
+	qboolean pathfound = qfalse;
+	qboolean linked = qfalse;
+	qboolean linked2 = qfalse;
+	qboolean deleted = qfalse;
+	gentity_t *node;
+	if(g_pathediting.integer <= 0)
+	{
+		trap_SendServerCommand( ent-g_entities,
+			"print \"g_pathediting is off.\n\"");
+		return;
+	}
+	if(!g_pathpassword.string[0])
+	{
+		trap_SendServerCommand( ent-g_entities,
+			"print \"Password not set (g_pathpassword).\n\"");
+		return;
+	}
+	if(!ent->patheditor)
+	{
+		trap_SendServerCommand( ent-g_entities,
+			"print \"Wrong password (!password).\n\"");
+		return;
+	}
+	trap_Cvar_VariableStringBuffer( "mapname", map, sizeof( map ) );
+	for(i = 0; i < level.numPaths; i++ )
+	{
+		Ax = level.paths[i].coord[0];
+		Ay = level.paths[i].coord[1];
+		Az = level.paths[i].coord[2];
+		Bx = ent->s.pos.trBase[0];
+		By = ent->s.pos.trBase[1];
+		Bz = ent->s.pos.trBase[2];
+		deleted = qfalse;
+		for(i2 = 0;i2 < 5;i2++)
+		{
+			if(level.paths[i].nextid[i2] < 0)
+			{deleted = qtrue;}
+		}
+		if(deleted == qtrue)
+		{
+			deleted = qfalse;
+			continue;
+		}
+		distance = sqrt((Ax - Bx)*(Ax - Bx) + (Ay - By)*(Ay - By) + (Az - Bz)*(Az - Bz));
+		if(distance < 100)
+		{
+			nearbynodeid[numnearby] = i;
+			numnearby++;
+			continue;
+		}
+	}
+	if(trap_Argc( ) != 2 && trap_Argc( ) != 3)
+	{
+		trap_SendServerCommand( ent-g_entities,
+			"print \"Usage: node [add|connect|disconnect|random|move|cancel|timeout|action|clear|delete|save]\n\"");
+		for(i = 0;i < numnearby; i++)
+		{
+			trap_SendServerCommand( ent-g_entities,
+				va("print \"^5Nearby Node: %d ^2(X:%f Y:%f Z:%f) ^1%d %d %d %d %d ^3Random:^7%d ^3Timeout:^7%d ^3Action:^7%d\n\"", nearbynodeid[i],
+					level.paths[nearbynodeid[i]].coord[0],
+					level.paths[nearbynodeid[i]].coord[1],
+					level.paths[nearbynodeid[i]].coord[2],
+					level.paths[nearbynodeid[i]].nextid[0],
+					level.paths[nearbynodeid[i]].nextid[1],
+					level.paths[nearbynodeid[i]].nextid[2],
+					level.paths[nearbynodeid[i]].nextid[3],
+					level.paths[nearbynodeid[i]].nextid[4],
+					level.paths[nearbynodeid[i]].random,
+					level.paths[nearbynodeid[i]].timeout,
+					level.paths[nearbynodeid[i]].action) );
+		}
+		return;
+	}
+	if(trap_Argc( ) == 2 || trap_Argc( ) == 3)
+	{
+		trap_Argv( 1, cmd, sizeof( cmd ) );
+		if(numnearby > 1 && Q_stricmp( cmd, "cancel" ) && Q_stricmp( cmd, "save" ) )
+		{
+			trap_SendServerCommand( ent-g_entities,
+				"print \"Too many nodes nearby.\n\"");
+			return;
+		}
+		if(trap_Argc( ) == 3 && !Q_stricmp( cmd, "timeout" ))
+		{
+			if(numnearby <= 0)
+			{
+				trap_SendServerCommand( ent-g_entities,
+					"print \"No nearby nodes.\n\"");
+				return;
+			}
+			trap_Argv( 2, timeout, sizeof( timeout ) );
+			timeout2 = atoi(timeout);
+			if(timeout2 < 0){timeout2 = 500;}
+			else if(timeout2 > 100000){timeout2 = 100000;}
+			level.paths[nearbynodeid[0]].timeout = timeout2;
+			trap_SendServerCommand( ent-g_entities,
+				va("print \"Node timeout set to %d ms.\n\"",timeout2));
+			return;
+		}
+		else if(trap_Argc( ) == 3 && !Q_stricmp( cmd, "action" ))
+		{
+			if(numnearby <= 0)
+			{
+				trap_SendServerCommand( ent-g_entities,
+					"print \"No nearby nodes.\n\"");
+				return;
+			}
+			trap_Argv( 2, action, sizeof( action ) );
+			if(!Q_stricmp( action, "jump" ))
+			{level.paths[nearbynodeid[0]].action = BOT_JUMP;}
+			else if(!Q_stricmp( action, "wallclimb" ))
+			{level.paths[nearbynodeid[0]].action = BOT_WALLCLIMB;}
+			else if(!Q_stricmp( action, "kneel" ))
+			{level.paths[nearbynodeid[0]].action = BOT_KNEEL;}
+			else if(!Q_stricmp( action, "pounce" ))
+			{level.paths[nearbynodeid[0]].action = BOT_POUNCE;}
+			else if(!Q_stricmp( action, "none" ))
+			{level.paths[nearbynodeid[0]].action = 0;}
+			else
+			{trap_SendServerCommand( ent-g_entities,
+				"print \"Unknown action (jump,wallclimb,\n\"");return;}
+			trap_SendServerCommand( ent-g_entities,
+				"print \"Node action set.\n\"");
+			return;	
+		}
+		else if( !Q_stricmp( cmd, "add" ) )
+		{
+			if(numnearby > 0)
+			{
+				trap_SendServerCommand( ent-g_entities,
+					"print \"Too close to another node.\n\"");
+				return;
+			}
+			if(level.numPaths >= MAX_PATHS)
+			{
+				trap_SendServerCommand( ent-g_entities,
+					"print \"Reached Max amount of nodes.\n\"" );
+				return;
+			}
+			for(i = 0; i < level.numPaths; i++ )
+			{
+				for(i2 = 0;i2 < 5;i2++)
+				{
+					if(level.paths[i].nextid[i2] < 0)
+					{pathfound = qtrue;}
+				}
+				if(pathfound == qtrue)
+				{break;}
+			}
+			if(pathfound == qtrue)
+			{
+				level.paths[i].coord[0] = ent->s.pos.trBase[0];
+				level.paths[i].coord[1] = ent->s.pos.trBase[1];
+				level.paths[i].coord[2] = ent->s.pos.trBase[2];
+				level.paths[i].nextid[0] = 1000 + MAX_PATHS;
+				level.paths[i].nextid[1] = 1000 + MAX_PATHS;
+				level.paths[i].nextid[2] = 1000 + MAX_PATHS;
+				level.paths[i].nextid[3] = 1000 + MAX_PATHS;
+				level.paths[i].nextid[4] = 1000 + MAX_PATHS;
+				level.paths[i].random = 0;
+				level.paths[i].timeout = 10000;
+				level.paths[i].action = 0;
+				trap_SendServerCommand( ent-g_entities,
+					va("print \"Saved Node #%d.\n\"", i));
+				if(level.drawpath == qtrue)
+				{
+					node = (gentity_t *)spawnnode( ent, i );
+				}
+			}
+			else
+			{
+				level.paths[level.numPaths].coord[0] = ent->s.pos.trBase[0];
+				level.paths[level.numPaths].coord[1] = ent->s.pos.trBase[1];
+				level.paths[level.numPaths].coord[2] = ent->s.pos.trBase[2];
+				level.paths[level.numPaths].nextid[0] = 1000 + MAX_PATHS;
+				level.paths[level.numPaths].nextid[1] = 1000 + MAX_PATHS;
+				level.paths[level.numPaths].nextid[2] = 1000 + MAX_PATHS;
+				level.paths[level.numPaths].nextid[3] = 1000 + MAX_PATHS;
+				level.paths[level.numPaths].nextid[4] = 1000 + MAX_PATHS;
+				level.paths[level.numPaths].random = 0;
+				level.paths[level.numPaths].timeout = 10000;
+				level.paths[level.numPaths].action = 0;
+				trap_SendServerCommand( ent-g_entities,
+					va("print \"Saved Node #%d.\n\"", level.numPaths));
+				if(level.drawpath == qtrue)
+				{
+					node = (gentity_t *)spawnnode(ent,level.numPaths);
+				}
+				level.numPaths++;
+			}
+		}
+		else if( !Q_stricmp( cmd, "connect" ) )
+		{
+			if(numnearby <= 0)
+			{
+				trap_SendServerCommand( ent-g_entities,
+					"print \"No nearby nodes.\n\"");
+				return;
+			}
+			ent->discpathid = -1;
+			ent->movepathid = -1;
+			if(ent->pathid < 0 || ent->pathid >= level.numPaths)
+			{
+				ent->pathid = nearbynodeid[0];
+				trap_SendServerCommand( ent-g_entities,
+					va("print \"Node #%d selected. Now select another node to connect to.\n\"", nearbynodeid[0]));
+				return;
+			}
+			else if(ent->pathid > -1 && ent->pathid < level.numPaths)
+			{
+				linked = qfalse;
+				linked2 = qfalse;
+				pathfound = qfalse;
+				if(nearbynodeid[0] == ent->pathid)
+				{
+					trap_SendServerCommand( ent-g_entities,
+						"print \"Node deselected.\n\"");
+					ent->pathid = -1;
+					return;
+				}
+				for(i = 0;i < 5;i++)
+				{
+					if(level.paths[nearbynodeid[0]].nextid[i] < level.numPaths)
+					{countz++;}
+					if(level.paths[ent->pathid].nextid[i] < level.numPaths)
+					{countz2++;}
+					if(level.paths[nearbynodeid[0]].nextid[i] == ent->pathid)
+					{
+						linked = qtrue;
+					}
+					if(level.paths[ent->pathid].nextid[i] == nearbynodeid[0])
+					{
+						linked2 = qtrue;
+					}
+				}
+				if(countz >= 5)
+				{
+					trap_SendServerCommand( ent-g_entities,
+						"print \"This node is full.\n\"");
+					//ent->pathid = -1;
+					return;
+				}
+				if(countz2 >= 5)
+				{
+					trap_SendServerCommand( ent-g_entities,
+						"print \"Selected node is full.\n\"");
+					ent->pathid = -1;
+					return;
+				}
+				if(linked == qtrue && linked2 == qtrue)
+				{
+					trap_SendServerCommand( ent-g_entities,
+						"print \"Both nodes are already linked.\n\"");
+					ent->pathid = -1;
+					return;
+				}
+				countz = 0;
+				countz2 = 0;
+				for(i = 0;i < 5;i++)
+				{
+					if(level.paths[nearbynodeid[0]].nextid[i] >= MAX_PATHS)
+					{countz = i; i = 5;break;}
+				}
+				for(i = 0;i < 5;i++)
+				{
+					if(level.paths[ent->pathid].nextid[i] >= MAX_PATHS)
+					{countz2 = i; i = 5; break;}
+				}
+				if(linked == qtrue)
+				{
+					trap_SendServerCommand( ent-g_entities,
+						va("print \"Node #%d is already linked to selected. Linking selected to this node.\n\"", nearbynodeid[0]));
+					level.paths[ent->pathid].nextid[countz2] = nearbynodeid[0];
+					trap_SendServerCommand( ent-g_entities,
+						va("print \"#%d ----> #%d \n\"", ent->pathid, nearbynodeid[0]));
+					ent->pathid = -1;
+					return;
+				}
+				if(linked2 == qtrue)
+				{
+					trap_SendServerCommand( ent-g_entities,
+						va("print \"Selected node #%d is already linked to this. Linking this to selected node.\n\"", ent->pathid));
+					level.paths[nearbynodeid[0]].nextid[countz] = ent->pathid;
+					trap_SendServerCommand( ent-g_entities,
+						va("print \"#%d ----> #%d \n\"", nearbynodeid[0], ent->pathid));
+					ent->pathid = -1;
+					return;
+				}
+				if(linked == qfalse && linked2 == qfalse)
+				{
+					level.paths[ent->pathid].nextid[countz2] = nearbynodeid[0];
+					level.paths[nearbynodeid[0]].nextid[countz] = ent->pathid;
+					trap_SendServerCommand( ent-g_entities,
+						va("print \"#%d <---> #%d \n\"", nearbynodeid[0], ent->pathid));
+					ent->pathid = -1;
+					return;
+				}
+			}
+			else
+			{ent->pathid = -1;}
+		}
+		else if( !Q_stricmp( cmd, "clear" ) )
+		{
+			if(numnearby <= 0)
+			{
+				trap_SendServerCommand( ent-g_entities,
+					"print \"No nearby nodes.\n\"");
+				return;
+			}
+			level.paths[nearbynodeid[0]].nextid[0] = 1000 + MAX_PATHS;
+			level.paths[nearbynodeid[0]].nextid[1] = 1000 + MAX_PATHS;
+			level.paths[nearbynodeid[0]].nextid[2] = 1000 + MAX_PATHS;
+			level.paths[nearbynodeid[0]].nextid[3] = 1000 + MAX_PATHS;
+			level.paths[nearbynodeid[0]].nextid[4] = 1000 + MAX_PATHS;
+			level.paths[nearbynodeid[0]].random = 0;
+			level.paths[nearbynodeid[0]].timeout = 0;
+			level.paths[nearbynodeid[0]].action = 0;
+			trap_SendServerCommand( ent-g_entities,
+				va("print \"Cleared Node #%d.\n\"", nearbynodeid[0]));
+			return;
+		}
+		else if( !Q_stricmp( cmd, "move" ) )
+		{
+			ent->discpathid = -1;
+			ent->pathid = -1;
+			if(ent->movepathid < 0 || ent->movepathid >= level.numPaths)
+			{
+				ent->movepathid = nearbynodeid[0];
+				trap_SendServerCommand( ent-g_entities,
+					va("print \"Node #%d Selected.\n\"", nearbynodeid[0]));
+				return;
+			}
+			else if(ent->movepathid >= 0 && ent->movepathid < level.numPaths)
+			{
+				if(nearbynodeid[0] == ent->movepathid)
+				{
+					trap_SendServerCommand( ent-g_entities,
+						"print \"Node deselected.\n\"");
+					ent->movepathid = -1;
+					return;
+				}
+				if(numnearby > 0)
+				{
+					trap_SendServerCommand( ent-g_entities,
+						"print \"Too close to another node.\n\"");
+					return;
+				}
+				level.paths[ent->movepathid].coord[0] = ent->s.pos.trBase[0];
+				level.paths[ent->movepathid].coord[1] = ent->s.pos.trBase[1];
+				level.paths[ent->movepathid].coord[2] = ent->s.pos.trBase[2];
+				trap_SendServerCommand( ent-g_entities,
+					va("print \"Moved node #%d to this location.\n\"", ent->movepathid));
+				ent->movepathid = -1;
+			}
+			else{ent->movepathid = -1;}
+			return;
+		}
+		else if( !Q_stricmp( cmd, "delete" ) )
+		{
+			ent->movepathid = -1;
+			ent->pathid = -1;
+			ent->discpathid = -1;
+			if(numnearby <= 0)
+			{
+				trap_SendServerCommand( ent-g_entities,
+					"print \"No nearby nodes.\n\"");
+				return;
+			}
+			for(i = 0; i < level.numPaths; i++ )
+			{
+				for(i2 = 0;i2 < 5;i2++)
+				{
+					if(level.paths[i].nextid[i2] == nearbynodeid[0])
+					{
+						level.paths[i].nextid[i2] = 1000 + MAX_PATHS;
+					}
+				}
+			}
+			level.paths[nearbynodeid[0]].nextid[0] = -1;
+			level.paths[nearbynodeid[0]].nextid[1] = -1;
+			level.paths[nearbynodeid[0]].nextid[2] = -1;
+			level.paths[nearbynodeid[0]].nextid[3] = -1;
+			level.paths[nearbynodeid[0]].nextid[4] = -1;
+			trap_SendServerCommand( ent-g_entities,
+				va("print \"Deleted Node #%d. It remains disabled until written over.  Links to other paths removed.\n\"", nearbynodeid[0]));
+		}
+		else if( !Q_stricmp( cmd, "disconnect" ) )
+		{
+			ent->movepathid = -1;
+			ent->pathid = -1;
+			if(numnearby <= 0)
+			{
+				trap_SendServerCommand( ent-g_entities,
+					"print \"No nearby nodes.\n\"");
+				return;
+			}
+			if(ent->discpathid < 0 || ent->discpathid >= level.numPaths)
+			{
+				ent->discpathid = nearbynodeid[0];
+				trap_SendServerCommand( ent-g_entities,
+					va("print \"Node #%d Selected.\n\"", nearbynodeid[0]));
+				return;
+			}
+			else if(ent->discpathid >= 0 && ent->discpathid < level.numPaths)
+			{
+				if(nearbynodeid[0] == ent->discpathid)
+				{
+					trap_SendServerCommand( ent-g_entities,
+						"print \"Node deselected.\n\"");
+					ent->discpathid = -1;
+					return;
+				}
+				for(i = 0;i < 5;i++)
+				{
+					if(level.paths[nearbynodeid[0]].nextid[i] == ent->discpathid)
+					{
+						level.paths[nearbynodeid[0]].nextid[i] = 1000 + MAX_PATHS;
+					}
+					if(level.paths[ent->discpathid].nextid[i] == nearbynodeid[0])
+					{
+						level.paths[ent->discpathid].nextid[i] = 1000 + MAX_PATHS;
+					}
+				}
+				trap_SendServerCommand( ent-g_entities,
+					va("print \"#%d <-X-> #%d \n\"", nearbynodeid[0], ent->discpathid));
+				ent->discpathid = -1;
+			}
+			return;
+		}
+		else if( !Q_stricmp( cmd, "cancel" ) )
+		{
+			ent->pathid = -1;
+			ent->movepathid = -1;
+			ent->discpathid = -1;
+			trap_SendServerCommand( ent-g_entities,
+				"print \"[Connect/Move/Disconnect] selected nodes are deselected.\n\"");
+		}
+		else if( !Q_stricmp( cmd, "random" ) )
+		{
+			if(numnearby <= 0)
+			{
+				trap_SendServerCommand( ent-g_entities,
+					"print \"No nearby nodes.\n\"");
+				return;
+			}
+			if(level.paths[nearbynodeid[0]].random <= 0)
+			{
+				level.paths[nearbynodeid[0]].random = 1;
+				trap_SendServerCommand( ent-g_entities,
+					va("print \"Node #%d is set random.\n\"", nearbynodeid[0]));
+				return;
+			}
+			else if(level.paths[nearbynodeid[0]].random > 0)
+			{
+				level.paths[nearbynodeid[0]].random = 0;
+				trap_SendServerCommand( ent-g_entities,
+					va("print \"Node #%d is set consecutive.\n\"", nearbynodeid[0]));
+				return;
+			}
+			return;
+		}
+		else if( !Q_stricmp( cmd, "save" ) )
+		{
+			delpath = qfalse;
+			Com_sprintf( fileName, sizeof( fileName ), "paths/%s/path.dat", map );
+
+			len = trap_FS_FOpenFile( fileName, &f, FS_WRITE );
+			if( len < 0 )
+			{
+				trap_SendServerCommand( ent-g_entities,
+					"print \"Couldn't Open File.  Created a New file.\n\"");
+			}
+			//level.numPaths = 0;
+			for(i = 0; i < level.numPaths; i++ )
+			{
+				for(i2 = 0;i2 < 5;i2++)
+				{
+					if(level.paths[i].nextid[i2] < 0)
+					{delpath = qtrue;}
+				}
+				if(delpath == qtrue)
+				{
+					delpath = qfalse;
+					//level.numPaths++;
+					continue;
+				}
+				s = va( "%d %f %f %f %d %d %d %d %d %d %d %d\n",
+					i,
+					level.paths[i].coord[0],
+					level.paths[i].coord[1],
+					level.paths[i].coord[2],
+					level.paths[i].nextid[0],
+					level.paths[i].nextid[1],
+					level.paths[i].nextid[2],
+					level.paths[i].nextid[3],
+					level.paths[i].nextid[4],
+					level.paths[i].random,
+					level.paths[i].timeout,
+					level.paths[i].action);
+				//level.numPaths++;
+				trap_FS_Write( s, strlen( s ), f );
+			}
+			trap_FS_FCloseFile( f );
+			trap_SendServerCommand( -1,
+				"print \"Saved Path.\n\"");
+			return;
+		}
+		else
+		{
+			trap_SendServerCommand( ent-g_entities,
+			"print \"Usage: node [add|connect|disconnect|random|move|cancel|timeout|action|clear|delete|save]\n\"");
+			trap_SendServerCommand( ent-g_entities,
+				"print \"Unknown option\n\"");
+			return;
+		}
+	}
+	return;
+}
+
+
 commands_t cmds[ ] = {
   { "a", CMD_MESSAGE|CMD_INTERMISSION, Cmd_AdminMessage_f },
   { "build", CMD_TEAM|CMD_LIVING, Cmd_Build_f },
@@ -3128,6 +3672,7 @@
   { "m", CMD_MESSAGE|CMD_INTERMISSION, Cmd_PrivateMessage_f },
   { "mt", CMD_MESSAGE|CMD_INTERMISSION, Cmd_PrivateMessage_f },
   { "noclip", CMD_CHEAT_TEAM, Cmd_Noclip_f },
+  { "node", CMD_TEAM|CMD_LIVING, Cmd_Node_f },
   { "notarget", CMD_CHEAT|CMD_TEAM|CMD_LIVING, Cmd_Notarget_f },
   { "reload", CMD_HUMAN|CMD_LIVING, Cmd_Reload_f },
   { "say", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
Index: Makefile
===================================================================
--- Makefile	(revision 2220)
+++ Makefile	(working copy)
@@ -18,25 +18,25 @@
 endif
 
 ifndef BUILD_STANDALONE
-  BUILD_STANDALONE =
+  BUILD_STANDALONE =0
 endif
 ifndef BUILD_CLIENT
-  BUILD_CLIENT     =
+  BUILD_CLIENT     =0
 endif
 ifndef BUILD_CLIENT_SMP
-  BUILD_CLIENT_SMP =
+  BUILD_CLIENT_SMP =0
 endif
 ifndef BUILD_SERVER
-  BUILD_SERVER     =
+  BUILD_SERVER     =0
 endif
 ifndef BUILD_GAME_SO
-  BUILD_GAME_SO    =
+  BUILD_GAME_SO    =0
 endif
 ifndef BUILD_GAME_QVM
-  BUILD_GAME_QVM   =
+  BUILD_GAME_QVM   =1
 endif
 ifndef BUILD_MISSIONPACK
-  BUILD_MISSIONPACK=
+  BUILD_MISSIONPACK=0
 endif
 
 ifneq ($(PLATFORM),darwin)
@@ -208,10 +208,12 @@
 VERSION=gpp1
 
 USE_SVN=
+SVN_VERSION=
 ifeq ($(wildcard .svn),.svn)
   SVN_REV=$(shell LANG=C svnversion .)
   ifneq ($(SVN_REV),)
     VERSION:=$(VERSION)_SVN$(SVN_REV)
+    SVN_VERSION=svn$(SVN_REV)
     USE_SVN=1
   endif
 endif
@@ -354,7 +356,6 @@
 
 ifeq ($(PLATFORM),darwin)
   HAVE_VM_COMPILED=true
-  LIBS = -framework Cocoa
   CLIENT_LIBS=
   OPTIMIZEVM=
 
@@ -411,7 +412,7 @@
   #  the file has been modified by each build.
   LIBSDLMAIN=$(B)/libSDLmain.a
   LIBSDLMAINSRC=$(LIBSDIR)/macosx/libSDLmain.a
-  CLIENT_LIBS += -framework IOKit -framework OpenGL \
+  CLIENT_LIBS += -framework Cocoa -framework IOKit -framework OpenGL \
     $(LIBSDIR)/macosx/libSDL-1.2.0.dylib
 
   OPTIMIZEVM += -falign-loops=16
@@ -448,6 +449,8 @@
     WINDRES=windres
   endif
 
+  ARCH=x86
+
   BASE_CFLAGS = -Wall -fno-strict-aliasing -Wimplicit -Wstrict-prototypes \
     -DUSE_ICON
   CLIENT_CFLAGS =
@@ -472,28 +475,20 @@
     CLIENT_CFLAGS += -DUSE_CODEC_VORBIS
   endif
 
-  ifeq ($(ARCH),x64)
-    OPTIMIZEVM = -O3 -fno-omit-frame-pointer \
-      -falign-loops=2 -funroll-loops -falign-jumps=2 -falign-functions=2 \
-      -fstrength-reduce
-    OPTIMIZE = $(OPTIMIZEVM) --fast-math
-    HAVE_VM_COMPILED = true
-  endif
-  ifeq ($(ARCH),x86)
-    OPTIMIZEVM = -O3 -march=i586 -fno-omit-frame-pointer \
-      -falign-loops=2 -funroll-loops -falign-jumps=2 -falign-functions=2 \
-      -fstrength-reduce
-    OPTIMIZE = $(OPTIMIZEVM) -ffast-math
-    HAVE_VM_COMPILED = true
-  endif
+  OPTIMIZEVM = -O3 -march=i586 -fno-omit-frame-pointer \
+    -falign-loops=2 -funroll-loops -falign-jumps=2 -falign-functions=2 \
+    -fstrength-reduce
+  OPTIMIZE = $(OPTIMIZEVM) -ffast-math
 
+  HAVE_VM_COMPILED = true
+
   SHLIBEXT=dll
   SHLIBCFLAGS=
   SHLIBLDFLAGS=-shared $(LDFLAGS)
 
   BINEXT=.exe
 
-  LIBS= -lws2_32 -lwinmm -lpsapi
+  LIBS= -lws2_32 -lwinmm
   CLIENT_LDFLAGS = -mwindows
   CLIENT_LIBS = -lgdi32 -lole32 -lopengl32
 
@@ -503,11 +498,7 @@
     ifneq ($(USE_CURL_DLOPEN),1)
       ifeq ($(USE_LOCAL_HEADERS),1)
         CLIENT_CFLAGS += -DCURL_STATICLIB
-        ifeq ($(ARCH),x64)
-	  CLIENT_LIBS += $(LIBSDIR)/win64/libcurl.a
-	else
-          CLIENT_LIBS += $(LIBSDIR)/win32/libcurl.a
-        endif
+        CLIENT_LIBS += $(LIBSDIR)/win32/libcurl.a
       else
         CLIENT_LIBS += $(CURL_LIBS)
       endif
@@ -521,22 +512,14 @@
   ifeq ($(ARCH),x86)
     # build 32bit
     BASE_CFLAGS += -m32
-  else
-    BASE_CFLAGS += -m64
   endif
 
   # libmingw32 must be linked before libSDLmain
   CLIENT_LIBS += -lmingw32
   ifeq ($(USE_LOCAL_HEADERS),1)
     CLIENT_CFLAGS += -I$(SDLHDIR)/include
-    ifeq ($(ARCH), x86)
     CLIENT_LIBS += $(LIBSDIR)/win32/libSDLmain.a \
                       $(LIBSDIR)/win32/libSDL.dll.a
-    else
-    CLIENT_LIBS += $(LIBSDIR)/win64/libSDLmain.a \
-                      $(LIBSDIR)/win64/libSDL.dll.a \
-                      $(LIBSDIR)/win64/libSDL.a
-    endif
   else
     CLIENT_CFLAGS += $(SDL_CFLAGS)
     CLIENT_LIBS += $(SDL_LIBS)
@@ -552,17 +535,46 @@
 
 ifeq ($(PLATFORM),freebsd)
 
-  # flags
-  BASE_CFLAGS = $(shell env MACHINE_ARCH=$(ARCH) make -f /dev/null -VCFLAGS) \
-    -Wall -fno-strict-aliasing -Wimplicit -Wstrict-prototypes \
-    -DUSE_ICON -DMAP_ANONYMOUS=MAP_ANON
+  ifneq (,$(findstring alpha,$(shell uname -m)))
+    ARCH=axp
+  else #default to x86
+    ARCH=x86
+  endif #alpha test
+
+  BASE_CFLAGS = -Wall -fno-strict-aliasing -Wimplicit -Wstrict-prototypes \
+    -DUSE_ICON
   CLIENT_CFLAGS = $(SDL_CFLAGS)
   SERVER_CFLAGS = 
-  HAVE_VM_COMPILED = true
 
-  OPTIMIZEVM = -O3 -funroll-loops -fomit-frame-pointer -ffast-math
-  OPTIMIZE = $(OPTIMIZEVM)
+  ifeq ($(USE_OPENAL),1)
+    CLIENT_CFLAGS += -DUSE_OPENAL
+    ifeq ($(USE_OPENAL_DLOPEN),1)
+      CLIENT_CFLAGS += -DUSE_OPENAL_DLOPEN
+    endif
+  endif
 
+  ifeq ($(USE_CODEC_VORBIS),1)
+    CLIENT_CFLAGS += -DUSE_CODEC_VORBIS
+  endif
+
+  OPTIMIZEVM = -O3 -funroll-loops -fomit-frame-pointer
+
+  ifeq ($(ARCH),axp)
+    BASE_CFLAGS += -DNO_VM_COMPILED
+    OPTIMIZEVM += -fexpensive-optimizations
+  else
+  ifeq ($(ARCH),x86)
+    OPTIMIZEVM += -mtune=pentiumpro \
+      -march=pentium -pipe -falign-loops=2 -falign-jumps=2 \
+      -falign-functions=2 -funroll-loops -fstrength-reduce
+    HAVE_VM_COMPILED=true
+  else
+    BASE_CFLAGS += -DNO_VM_COMPILED
+  endif
+  endif
+
+  OPTIMIZE = $(OPTIMIZEVM) -ffast-math
+
   SHLIBEXT=so
   SHLIBCFLAGS=-fPIC
   SHLIBLDFLAGS=-shared $(LDFLAGS)
@@ -575,43 +587,16 @@
 
   CLIENT_LIBS += $(SDL_LIBS) -lGL
 
-  # optional features/libraries
   ifeq ($(USE_OPENAL),1)
-    CLIENT_CFLAGS += -DUSE_OPENAL
-    ifeq ($(USE_OPENAL_DLOPEN),1)
-      CLIENT_CFLAGS += -DUSE_OPENAL_DLOPEN
+    ifneq ($(USE_OPENAL_DLOPEN),1)
       CLIENT_LIBS += $(THREAD_LIBS) -lopenal
     endif
   endif
 
-  ifeq ($(USE_CURL),1)
-    CLIENT_CFLAGS += -DUSE_CURL
-    ifeq ($(USE_CURL_DLOPEN),1)
-      CLIENT_CFLAGS += -DUSE_CURL_DLOPEN
-      CLIENT_LIBS += -lcurl
-    endif
-  endif
-
   ifeq ($(USE_CODEC_VORBIS),1)
-    CLIENT_CFLAGS += -DUSE_CODEC_VORBIS
-  endif
-
-  ifeq ($(USE_CODEC_VORBIS),1)
     CLIENT_LIBS += -lvorbisfile -lvorbis -logg
   endif
 
-  # cross-compiling tweaks
-  ifeq ($(ARCH),i386)
-    ifeq ($(CROSS_COMPILING),1)
-      BASE_CFLAGS += -m32
-    endif
-  endif
-  ifeq ($(ARCH),amd64)
-    ifeq ($(CROSS_COMPILING),1)
-      BASE_CFLAGS += -m64
-    endif
-  endif
-
 else # ifeq freebsd
 
 #############################################################################
@@ -871,7 +856,9 @@
 
 ifeq ($(USE_INTERNAL_ZLIB),1)
   BASE_CFLAGS += -DNO_GZIP
-  BASE_CFLAGS += -I$(ZDIR)
+  ifneq ($(USE_LOCAL_HEADERS),1)
+    BASE_CFLAGS += -I$(ZDIR)
+  endif
 else
   LIBS += -lz
 endif
@@ -901,6 +888,7 @@
 endif
 
 BASE_CFLAGS += -DPRODUCT_VERSION=\\\"$(VERSION)\\\"
+BASE_CFLAGS += -DSVN_VERSION=\\\"$(SVN_VERSION)\\\"
 
 ifeq ($(V),1)
 echo_cmd=@:
@@ -1072,7 +1060,7 @@
 # QVM BUILD TOOLS
 #############################################################################
 
-TOOLS_OPTIMIZE = -g -Wall -fno-strict-aliasing
+TOOLS_OPTIMIZE = -g -O2 -Wall -fno-strict-aliasing
 TOOLS_CFLAGS += $(TOOLS_OPTIMIZE) \
                 -DTEMPDIR=\"$(TEMPDIR)\" -DSYSTEM=\"\" \
                 -I$(Q3LCCSRCDIR) \
@@ -1194,17 +1182,17 @@
 
 define DO_CGAME_Q3LCC
 $(echo_cmd) "CGAME_Q3LCC $<"
-$(Q)$(Q3LCC) -DPRODUCT_VERSION=\"$(VERSION)\" -DCGAME -o $@ $<
+$(Q)$(Q3LCC) -DPRODUCT_VERSION=\"$(VERSION)\" -DCGAME -DSVN_VERSION=\"$(SVN_VERSION)\" -o $@ $<
 endef
 
 define DO_GAME_Q3LCC
 $(echo_cmd) "GAME_Q3LCC $<"
-$(Q)$(Q3LCC) -DPRODUCT_VERSION=\"$(VERSION)\" -DGAME -o $@ $<
+$(Q)$(Q3LCC) -DPRODUCT_VERSION=\"$(VERSION)\" -DGAME -DSVN_VERSION=\"$(SVN_VERSION)\" -o $@ $<
 endef
 
 define DO_UI_Q3LCC
 $(echo_cmd) "UI_Q3LCC $<"
-$(Q)$(Q3LCC) -DPRODUCT_VERSION=\"$(VERSION)\" -DUI -o $@ $<
+$(Q)$(Q3LCC) -DPRODUCT_VERSION=\"$(VERSION)\" -DUI -DSVN_VERSION=\"$(SVN_VERSION)\" -o $@ $<
 endef
 
 
@@ -1433,12 +1421,6 @@
   ifeq ($(ARCH),x86_64)
     Q3OBJ += $(B)/client/vm_x86_64.o $(B)/client/vm_x86_64_assembler.o
   endif
-  ifeq ($(ARCH),amd64)
-    Q3OBJ += $(B)/client/vm_x86_64.o $(B)/client/vm_x86_64_assembler.o
-  endif
-  ifeq ($(ARCH),x64)
-    Q3OBJ += $(B)/client/vm_x86_64.o $(B)/client/vm_x86_64_assembler.o
-  endif
   ifeq ($(ARCH),ppc)
     Q3OBJ += $(B)/client/vm_powerpc.o $(B)/client/vm_powerpc_asm.o
   endif
@@ -1461,7 +1443,7 @@
 
 ifeq ($(PLATFORM),darwin)
   Q3OBJ += \
-    $(B)/client/sys_osx.o
+    $(B)/client/sys_cocoa.o
 endif
 
 ifeq ($(USE_MUMBLE),1)
@@ -1566,12 +1548,6 @@
   ifeq ($(ARCH),x86_64)
     Q3DOBJ += $(B)/ded/vm_x86_64.o $(B)/ded/vm_x86_64_assembler.o
   endif
-  ifeq ($(ARCH),amd64)
-    Q3DOBJ += $(B)/ded/vm_x86_64.o $(B)/ded/vm_x86_64_assembler.o
-  endif
-  ifeq ($(ARCH),x64)
-    Q3DOBJ += $(B)/ded/vm_x86_64.o $(B)/ded/vm_x86_64_assembler.o
-  endif
   ifeq ($(ARCH),ppc)
     Q3DOBJ += $(B)/ded/vm_powerpc.o $(B)/ded/vm_powerpc_asm.o
   endif
@@ -1594,11 +1570,6 @@
     $(B)/ded/con_tty.o
 endif
 
-ifeq ($(PLATFORM),darwin)
-  Q3DOBJ += \
-    $(B)/ded/sys_osx.o
-endif
-
 $(B)/tremded$(FULLBINEXT): $(Q3DOBJ)
 	$(echo_cmd) "LD $@"
 	$(Q)$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(Q3DOBJ) $(LIBS)
@@ -1687,6 +1658,7 @@
   $(B)/base/game/g_maprotation.o \
   $(B)/base/game/g_weapon.o \
   $(B)/base/game/g_admin.o \
+  $(B)/base/game/g_bot.o \
   $(B)/base/game/g_namelog.o \
   \
   $(B)/base/qcommon/q_math.o \
